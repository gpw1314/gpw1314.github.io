<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[决定了，加油]]></title>
      <url>/2017/09/20/%E5%86%B3%E5%AE%9A%E4%BA%86%EF%BC%8C%E5%8A%A0%E6%B2%B9/</url>
      <content type="html"><![CDATA[<p> 兜兜圈圈，转转悠悠，本人17届毕业，在湖北一个非知名的二本院校读的软件工程，大学生活并没有想象的那么美好，但是也还是过的不错的，在旁边的同学影响下开始学习Android，本身就是计算机专业，但是有一定的基础可以去学习，开始学习还是感觉非常有趣的，主要是通过黑马视频教学，和各种找网络资源视频去学习，很少看书，觉得挺可惜，学习的是只有其形而不得其神呀，而且当时学习也是两天打渔三天晒网的状态，现在想想悔恨当初，在我所在的所大学，我还算好的，知道学习点东西，大四就直接去一家公司实习，做了大半年，从开始的艰难变得逐渐适应起来，下面是个人总结需要学习的东西</p>
<h2 id="数据机构和算法"><a href="#数据机构和算法" class="headerlink" title="数据机构和算法"></a>数据机构和算法</h2><p><strong>数组</strong></p>
<p> 数组由一组相同的数据类型组成。它存储在连续的内存空间内，使用索引可以找到元素的地址。数组包括一维数组和多维数组,一维数组是最简单的数据结构,也是最常用的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">平均</th>
<th style="text-align:center">最坏</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">空间（Space）</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">查找（Search）</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">插入（Insert）</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">删除（Delete）</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
</tbody>
</table>
<p><strong>链表</strong></p>
<p>   链表看起来更像树，而不是数组，它使用一组结点来表示一个序列。每一个结点都包含数据和一个指针。在链表中，结点中的数据可以为任意类型，而指针则是指向下一结点的引用。链表包含一个头结点和一个尾结点。头结点是链表中的第一个结点，尾结点是最后一个结点。链表不是一个循环数据结构，所以尾结点没有指向头结点的指针，指针为空。一些基础方法的时间复杂度如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">平均</th>
<th style="text-align:center">最坏</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">空间 (Space)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">查找 (Search)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">插入 (Insert)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">删除 (Delete)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(1)</td>
</tr>
</tbody>
</table>
<p><strong>双向链表</strong></p>
<p>   一个双向链表首先是一个链表，但是在每个结点中有两个指针，前驱指针指向前驱结点，后继指针指向后继结点。双向链表也有一个头结点，头结点的后继指针指向第一个结点。最后一个结点的后继指针指向空，但是如果最后一个结点的后继指针指向第一个结点，这时称这个链表为双向循环链表。双向循环链表能非常方便地从每个结点查找它的前驱结点和后继结点。<img src="https://i.imgur.com/o7uPZtZ.png" alt=""></p>
<table>
<thead>
<tr>
<th>算法</th>
<th>平均</th>
<th>最坏 </th>
</tr>
</thead>
<tbody>
<tr>
<td>空间 (Space)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>查找 (Search)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入 (Insert)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>删除 (Delete)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p> <strong>栈</strong></p>
<p>   栈是一个有着「后进先出」特性的基础数据结构，这就意味着最后一个入栈的元素，也是第一个出栈的。栈就像是一堆书，想要得到书堆中的第一本书（最下面一本），必须把其他的书都先拿走。向栈中添加一个元素的操作被称为 Push（入栈），删除一个元素的操作被称为 Pop（出栈），查看且不删除最后一个入栈的元素的操作被称为 Top 。<a href="https://en.wikibooks.org/wiki/Data_Structures/Stacks_and_Queues#Performance_Analysis" target="_blank" rel="external">实现栈的常用方法是使用链表（LinkedList），也可以使用不允许空值的 StackArray（使用数组实现），还有允许空值的 Vector</a></p>
<p> <strong>队列</strong></p>
<p><strong>优先队列</strong>    </p>
<p><strong>动态编程</strong></p>
<p><strong>字符串操作</strong></p>
<p><strong>二叉树</strong></p>
<p><strong>二叉搜索树</strong></p>
<p><strong>排序算法</strong></p>
<p><strong>哈希表与哈希图</strong></p>
<p><strong>广度优先搜索</strong></p>
<p><strong>深度优先搜索</strong></p>
<p><strong>贪心算法</strong></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计分类"><a href="#设计分类" class="headerlink" title="设计分类"></a>设计分类</h3><p><strong>结构型模式</strong></p>
<ul>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>单例模式</li>
<li>建造者模式</li>
<li>原型模式</li>
</ul>
<p><strong>结构型模式</strong></p>
<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<p><strong>行为型模式</strong></p>
<ul>
<li>策略模式</li>
<li>模板方法模式</li>
<li>观察者模式</li>
<li>迭代子模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式                                         </li>
<li>中介者模式                                                  </li>
<li>解释器模式</li>
</ul>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ul>
<li>开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。                                                                                                                                               </li>
<li>里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</li>
<li>依赖倒转原则（Dependence Inversion Principle）<br>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</li>
<li>接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>迪米特法则（最少知道原则）（Demeter Principle）<br>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li>合成复用原则（Composite Reuse Principle）<br>原则是尽量使用合成/聚合的方式，而不是使用继承。</li>
</ul>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul>
<li>解释一下 OOP 的概念<ul>
<li>面向对象编程是使用类，对象，<a href="https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="external">继承性</a>)，<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="external">多态性</a>)，<a href="https://zh.wikipedia.org/wiki/%E5%B0%81%E8%A3%9D_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" target="_blank" rel="external">封装性</a>)和<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" target="_blank" rel="external">抽象</a>)的一种程序设计方法。</li>
</ul>
</li>
<li>抽象类和接口的区别？<a href="https://arjun-sna.github.io/java/2017/02/02/abstractvsinterface/" target="_blank" rel="external">Link</a><ul>
<li>抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。</li>
<li>接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 <code>implements</code> 来实现接口，接口可以用 <code>extends</code> 来继承其他接口。</li>
</ul>
</li>
<li>序列化是什么?如何实现它?<ul>
<li>序列化是一种将对象转换为字节流的过程，目的是为了将该对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态及数据信息。Java中，有两种方式可以实现序列化，既可以实现Serializable接口，也可以实现Parcelable接口。然而，在Android中，我们不应该使用Serializable接口。因为Serializable接口使用了反射机制，这个过程相对缓慢，而且往往会产生出很多临时对象，这样可能会触发垃圾回收器频繁地进行垃圾回收。相比而言，Parcelable接口比Serializable接口效率更高，性能方面要高出10x多倍。</li>
</ul>
</li>
<li>什么是单例？<ul>
<li>单例模式指的是一个类只能被初始化一次，即只有一个实例。<a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="external">单例模式限定一个类只能拥有一个实例。这在系统中只需要一个实例来和其他模块协调工作时是很实用的。单例普遍使用在只需要一个或是限制一定数量实例的系统中。</a></li>
</ul>
</li>
<li>什么是匿名内部类？</li>
<li>对字符串进行 <code>==</code> 和 <code>equals()</code> 操作时有什么区别？</li>
<li><code>hashCode()</code> 和 <code>equals()</code> 何时使用？</li>
<li>Java 中的 <code>final</code>, <code>finally</code> 和 <code>finalize</code>?</li>
<li>什么是内存泄露，Java 是如何处理它的？</li>
<li>垃圾收集器是什么?它是如何工作的?<ul>
<li>所有的对象实例都在JVM管理的堆区域分配内存只要对象被引用，JVM就会认为它还存活于进程中。一旦对象不再被引用，就不能被应用程序所访问，垃圾收集器将删除它并重新声明未使用的内存。</li>
</ul>
</li>
<li>比较 <code>Arrays</code> 和 <code>ArrayLists</code>。</li>
<li>比较 <code>HashSet</code> 和 <code>TreeSet</code>。</li>
<li>Java 中的类型转换。</li>
<li>方法重载和重写的区别<ul>
<li>重载发生在编译时，重写发生在运行时。重载方法调用与其定义的绑定发生在编译时，但是重写方法调用与其定义的绑定在运行时发生。</li>
<li>静态方法可以重载，意味着一个类可以有多个同名的静态方法。静态方法不能被重写，即使在子类中声明了一个相同的静态方法，它与父类的相同方法无关。</li>
<li>最基本的区别是重载是在同一个类中完成的，重写父类需要有子类。重写是给父类的继承方法一个具体的实现。</li>
<li>静态绑定用于方法重载，动态绑定用于方法重写。性能：重载比重写更有效率，原因是方法重写的绑定是在运行时完成的。</li>
<li>私有方法和用 <code>final</code> 修饰的方法可以重载但不可重写。这意味着一个类可以有多个同名的 <code>private/final</code> 方法，子类不能重写父类的 <code>private/final</code> 方法。</li>
<li>方法重载的情况下不关心返回值类型， 它可以相同，也可以不同。但是方法重写的情况下可以有多个具体的返回值类型。</li>
<li>方法重载时参数列表必须不同，方法重写时参数列表必须相同。</li>
</ul>
</li>
<li>什么是访问修饰符？它们能做什么？</li>
<li>接口可以继承另一个接口吗？</li>
<li>Java 中 <code>static</code> 关键字是什么意思？</li>
<li>Java 中静态方法可以被重写吗？</li>
<li>什么是多态？什么是继承？</li>
<li><code>Integer</code> 和 <code>int</code> 之间的区别</li>
<li>Java 中的对象是否会以引用传递或者值传递？详细说明。</li>
<li>什么是 ThreadPoolExecutor？ <a href="https://blog.mindorks.com/threadpoolexecutor-in-android-8e9d22330ee3" target="_blank" rel="external">Link</a></li>
<li>本地变量、实例变量以及类变量之间的区别？</li>
<li>什么是反射？ <a href="http://tutorials.jenkov.com/java-reflection/index.html" target="_blank" rel="external">Link</a></li>
<li>在 Java 中什么是强引用、软引用、弱引用以及虚引用？</li>
<li>什么是依赖注入？能说几个依赖注入的库么？你使用过哪些？</li>
<li>关键字<code>synchronized</code>的作用是什么？</li>
<li>为什么说<code>String</code>不可变的？</li>
<li>修饰符<code>transient</code>和<code>volatile</code>的作用是什么？</li>
<li><code>finalize()</code>方法的作用是什么？</li>
<li>异常捕获中的 <code>try{}finally{}</code> 块儿是如何工作的?</li>
<li>对象的实例化和初始化之间的区别是什么?</li>
<li>静态块何时运行?</li>
<li>解释一下 Java 中的泛型?</li>
<li><code>StringBuffer</code> 和<code>StringBuilder</code> 的区别在哪里?</li>
<li><code>StringBuilder</code> 是怎么避免不可变字符串分配的问题？</li>
<li>什么是自动装箱和拆箱？</li>
<li>枚举和迭代器有什么区别？</li>
<li>Java 中 <em>fail-fast</em> 和 <em>fail-safe</em> 的区别？</li>
<li>什么是 Java 优先级队列？</li>
</ul>
<h2 id="Android核心"><a href="#Android核心" class="headerlink" title="Android核心"></a>Android核心</h2><ul>
<li>阐述一下 Activity 的生命周期。</li>
<li>谈谈 Android 的四大组件。</li>
<li>Service 与 IntentService 的区别。<a href="https://stackoverflow.com/a/15772151/5153275" target="_blank" rel="external">Link</a></li>
<li>Android 应用的结构是什么？</li>
<li>Android 应用中如何保存数据。</li>
<li>如何在 Android 应用中执行耗时操作。</li>
<li>两个 Fragment 之间如何通信。</li>
<li>阐述一下 Android 的通知系统。</li>
<li>两个不同的 app 之间如何交互。</li>
<li>什么是 Fragment？</li>
<li>为什么建议只使用默认的构造方法来创建 Fragment？<a href="https://stackoverflow.com/a/16042750/2809326" target="_blank" rel="external">Link</a></li>
<li>为什么 Bundle 被用来传递数据，为什么不能使用简单的 Map 数据结构？</li>
<li>阐述一下 Fragment 的生命周期。<a href="https://www.techsfo.com/blog/wp-content/uploads/2014/08/complete_android_fragment_lifecycle.png" target="_blank" rel="external">Link</a></li>
<li>如何理解 Android 的 Dialog ？</li>
<li>解释下 Android 的 View 。</li>
<li>你能创建自定义 View 吗？具体是如何创建的？</li>
<li>什么是 ViewGroup ，它与 View 的区别在哪里？</li>
<li>Fragment 和 Activity 有什么区别？它们之间又有什么关系？</li>
<li>谈谈 Serializable 接口和 Parcelable 接口的区别。在 Android 中最好使用哪种接口？</li>
<li>Activity 的启动模式有哪些？<a href="https://blog.mindorks.com/android-activity-launchmode-explained-cbc6cf996802" target="_blank" rel="external">Link</a></li>
<li>解释一下 Android 中的 Intent 。<a href="https://stackoverflow.com/questions/6578051/what-is-an-intent-in-android" target="_blank" rel="external">Link</a></li>
<li>什么是隐式 Intent ？</li>
<li>什么是显式 Intent ？</li>
<li>解释一下 AsyncTask 。</li>
<li>如何理解 Android 中的广播。<a href="https://stackoverflow.com/questions/5296987/what-is-broadcastreceiver-and-when-we-use-it" target="_blank" rel="external">Link</a></li>
<li>如何理解 Android 的 LocalBroadcastManager 。<a href="https://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="external">Link</a></li>
<li>什么是 JobScheduler ？<a href="http://www.vogella.com/tutorials/AndroidTaskScheduling/article.html" target="_blank" rel="external">Link</a></li>
<li>什么是 DDMS ？你可以用它来做什么？</li>
<li>解释一下什么是 support libary ，以及为什么要引入 support library ？<a href="http://martiancraft.com/blog/2015/06/android-support-library/" target="_blank" rel="external">Link</a></li>
<li>如何理解 Android 中的 ContentProvider 。它通常用来干什么？</li>
<li>什么是 Data Binding ？<a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">Link</a></li>
<li>Android 的核心组件具体都有什么？<a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank" rel="external">Link</a></li>
<li>什么是 ADB ？</li>
<li>什么是 ANR ？如何避免发生 ANR ？</li>
<li>AndroidManifest.xml 是什么？</li>
<li>解释一下 broadcast 和 intent 在 app 内传递消息的工作流程。</li>
<li>当 Bitmap 占用较多内存时，你是怎么处理的？</li>
<li>Android 应用有哪些不同的存储数据的方式？</li>
<li>什么是 Dalvik 虚拟机？</li>
<li>AsyncTask 的生命周期和(它所属的) Activity 的生命周期有什么关系？这种关系可能会导致什么样的问题？ 如何避免这些问题发生？</li>
<li>Intent filter 是用来做什么的？</li>
<li>什么是 Sticky Intent？<a href="http://www.androidinterview.com/what-is-a-sticky-intent/" target="_blank" rel="external">Link</a></li>
<li>什么是 AIDL ？列举一下通过 AIDL 创建被绑定的服务（bounded service）的步骤。</li>
<li>Android 的权限有多少个不同的保护等级？</li>
<li>在转屏时你如何保存 Activity 的状态？<a href="https://stackoverflow.com/questions/3915952/how-to-save-state-during-orientation-change-in-android-if-the-state-is-made-of-m" target="_blank" rel="external">Link</a></li>
<li>相对布局和线性布局的区别。</li>
<li>如何实现 XML 命名空间？</li>
<li>View.GONE 和 View.INVISIBLE 之间的区别。</li>
<li>Bitmap 和 .9（nine-patch）图片之间有什么区别？</li>
<li>谈谈位图池。<a href="https://blog.mindorks.com/how-to-use-bitmap-pool-in-android-56c71a55533c" target="_blank" rel="external">Link</a></li>
<li>在 Android 中如何避免内存泄漏？</li>
<li>Android 桌面的小部件是什么？</li>
<li>什么是 AAPT ？</li>
<li>你是如何在 Android 应用程序中发现内存泄漏的？</li>
<li>你如何排查应用崩溃的原因？</li>
<li>为什么你应该避免在主线程上运行非用户界面相关的代码？</li>
<li>你是如何适配不同分辨率的手机的？</li>
<li>如何理解 Doze 模式。如何理解应用程序待机模式（App Standby）。</li>
<li>在 Android 中，你可以使用什么来进行后台操作?</li>
<li>什么是 ORM ？它是如何工作的？</li>
<li>什么是 Loader ？</li>
<li>什么是 NDK ，为什么它是有用的？</li>
<li>如何理解严格模式（StrictMode）。 <a href="https://blog.mindorks.com/use-strictmode-to-find-things-you-did-by-accident-in-android-development-4cf0e7c8d997" target="_blank" rel="external">Link</a></li>
<li>什么是 Lint ？它的用途是什么？</li>
<li>什么是 SurfaceView ？</li>
<li>ListView 和 RecyclerView 有什么区别？</li>
<li>什么是 ViewHolder 模式？为什么我们应该使用它？</li>
<li>什么是 PendingIntent ？</li>
<li>你能手动调用垃圾回收吗？</li>
<li>周期地更新页面的最好方式是什么？</li>
<li>有哪些类型的广播？</li>
<li>你开发过组件吗？请描述一下。<a href="https://blog.mindorks.com/android-widgets-ad3d166458d3" target="_blank" rel="external">Link</a></li>
<li>如何理解上下文（Context）。怎么使用它？<a href="https://medium.com/p/understanding-context-in-android-application-330913e32514" target="_blank" rel="external">Link</a></li>
<li>你知道什么是视图树(View Tree)吗？怎样优化它的深度？</li>
<li>onTrimMemory() 方法是什么？</li>
<li>Android 应用可以使用多进程吗？怎样使用？</li>
<li>内存溢出（OutOfMemory）是怎么发生的？</li>
<li>文本样式接口（Spannable）是什么？</li>
<li>什么是过度绘制（overdraw）？</li>
<li>什么是渲染脚本（renderscript）？<a href="https://blog.mindorks.com/comparing-android-ndk-and-renderscript-1a718c01f6fe" target="_blank" rel="external">Link</a></li>
<li>Dalvik 虚拟机模式和 ART（Android Runtime）虚拟机模式的区别。</li>
<li>FlatBuffers 和 JSON 的区别。<a href="https://blog.mindorks.com/why-consider-flatbuffer-over-json-2e4aa8d4ed07" target="_blank" rel="external">Link</a></li>
<li>谈谈 Android 的注解。<a href="https://blog.mindorks.com/creating-custom-annotations-in-android-a855c5b43ed9" target="_blank" rel="external">Link1</a>, <a href="https://blog.mindorks.com/improve-your-android-coding-through-annotations-26b3273c137a" target="_blank" rel="external">Link2</a></li>
<li>描述一下约束布局（Constraint Layout）。<a href="https://blog.mindorks.com/using-constraint-layout-in-android-531e68019cd" target="_blank" rel="external">Link</a></li>
<li>阐述一下 Android 中的 HashMap , ArrayMap 和 SparseArray 。<a href="https://blog.mindorks.com/android-app-optimization-using-arraymap-and-sparsearray-f2b4e2e3dc47" target="_blank" rel="external">Link</a></li>
<li>阐述一下 Looper, Handler 和 HandlerThread 。<a href="https://blog.mindorks.com/android-core-looper-handler-and-handlerthread-bd54d69fe91a" target="_blank" rel="external">Link</a></li>
<li>如何降低 Android 应用的耗电量？<a href="https://blog.mindorks.com/battery-optimization-for-android-apps-f4ef6170ff70" target="_blank" rel="external">Link</a></li>
<li>SnapHelper 是什么？<a href="https://blog.mindorks.com/using-snaphelper-in-recyclerview-fc616b6833e8" target="_blank" rel="external">Link</a></li>
<li>在 Android 中怎么处理多点触控？<a href="https://arjun-sna.github.io/android/2016/07/20/multi-touch-android/" target="_blank" rel="external">link</a></li>
</ul>
<h2 id="坚持的心态"><a href="#坚持的心态" class="headerlink" title="坚持的心态"></a>坚持的心态</h2><ul>
<li>数组</li>
<li>数组</li>
<li>数组</li>
<li>数组</li>
</ul>
]]></content>
      
        
    </entry>
    
  
  
    
  
</search>
